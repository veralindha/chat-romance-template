"use strict";

exports.__esModule = true;
exports.render = render;
exports.default = void 0;

var _loading = _interopRequireDefault(require("../loading"));

var _ripple = _interopRequireDefault(require("../ripple"));

var _vue = require("vue");

var _elements = require("../utils/elements");

var _props = require("./props");

var _shared = require("../utils/shared");

var _locale = require("../locale");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _withScopeId = n => ((0, _vue.pushScopeId)(""), n = n(), (0, _vue.popScopeId)(), n);

var _hoisted_1 = {
  class: "var-list var--box",
  ref: "listEl"
};
var _hoisted_2 = {
  class: "var-list__loading"
};
var _hoisted_3 = {
  class: "var-list__loading-text"
};
var _hoisted_4 = {
  class: "var-list__finished"
};
var _hoisted_5 = {
  class: "var-list__detector",
  ref: "detectorEl"
};

function render(_ctx, _cache) {
  var _component_var_loading = (0, _vue.resolveComponent)("var-loading");

  var _directive_ripple = (0, _vue.resolveDirective)("ripple");

  return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_1, [(0, _vue.renderSlot)(_ctx.$slots, "default"), _ctx.loading ? (0, _vue.renderSlot)(_ctx.$slots, "loading", {
    key: 0
  }, () => [(0, _vue.createElementVNode)("div", _hoisted_2, [(0, _vue.createElementVNode)("div", _hoisted_3, (0, _vue.toDisplayString)(_ctx.dt(_ctx.loadingText, _ctx.pack.listLoadingText)), 1
  /* TEXT */
  ), (0, _vue.createVNode)(_component_var_loading, {
    size: "mini",
    radius: 10
  })])]) : (0, _vue.createCommentVNode)("v-if", true), _ctx.finished ? (0, _vue.renderSlot)(_ctx.$slots, "finished", {
    key: 1
  }, () => [(0, _vue.createElementVNode)("div", _hoisted_4, (0, _vue.toDisplayString)(_ctx.dt(_ctx.finishedText, _ctx.pack.listFinishedText)), 1
  /* TEXT */
  )]) : (0, _vue.createCommentVNode)("v-if", true), _ctx.error ? (0, _vue.renderSlot)(_ctx.$slots, "error", {
    key: 2
  }, () => [(0, _vue.withDirectives)((0, _vue.createElementVNode)("div", {
    class: "var-list__error",
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.load && _ctx.load(...args))
  }, [(0, _vue.createTextVNode)((0, _vue.toDisplayString)(_ctx.dt(_ctx.errorText, _ctx.pack.listErrorText)), 1
  /* TEXT */
  )], 512
  /* NEED_PATCH */
  ), [[_directive_ripple]])]) : (0, _vue.createCommentVNode)("v-if", true), (0, _vue.createElementVNode)("div", _hoisted_5, null, 512
  /* NEED_PATCH */
  )], 512
  /* NEED_PATCH */
  );
}

var _default = (0, _vue.defineComponent)({
  render,
  name: 'VarList',
  directives: {
    Ripple: _ripple.default
  },
  components: {
    VarLoading: _loading.default
  },
  props: _props.props,

  setup(props) {
    var listEl = (0, _vue.ref)(null);
    var detectorEl = (0, _vue.ref)(null);
    var scroller;

    var load = () => {
      var _props$onUpdateError, _props$onUpdateLoadi;

      (_props$onUpdateError = props['onUpdate:error']) == null ? void 0 : _props$onUpdateError.call(props, false);
      (_props$onUpdateLoadi = props['onUpdate:loading']) == null ? void 0 : _props$onUpdateLoadi.call(props, true);
      props.onLoad == null ? void 0 : props.onLoad();
    };

    var isReachBottom = () => {
      var containerBottom = scroller === window ? window.innerHeight : scroller.getBoundingClientRect().bottom;
      var {
        bottom: detectorBottom
      } = detectorEl.value.getBoundingClientRect();
      return detectorBottom - (0, _elements.toPxNum)(props.offset) <= containerBottom;
    }; // expose


    var check = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(function* () {
        yield (0, _vue.nextTick)();

        if ((0, _elements.isHidden)(listEl.value)) {
          return;
        }

        var {
          loading,
          finished,
          error
        } = props;

        if (!loading && !finished && !error && isReachBottom()) {
          load();
        }
      });

      return function check() {
        return _ref.apply(this, arguments);
      };
    }();

    (0, _vue.onMounted)(() => {
      scroller = (0, _elements.getParentScroller)(listEl.value);
      props.immediateCheck && check();
      scroller.addEventListener('scroll', check);
    });
    (0, _vue.onUnmounted)(() => {
      scroller.removeEventListener('scroll', check);
    });
    return {
      pack: _locale.pack,
      listEl,
      detectorEl,
      dt: _shared.dt,
      isNumber: _shared.isNumber,
      load,
      check
    };
  }

});

exports.default = _default;