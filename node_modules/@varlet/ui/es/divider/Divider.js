function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import { defineComponent, computed, reactive, onMounted, onUpdated, toRefs } from 'vue';
import { toSizeUnit } from '../utils/elements';
import { isBool, toNumber } from '../utils/shared';
import { props } from './props';
import { renderSlot as _renderSlot, toDisplayString as _toDisplayString, openBlock as _openBlock, createElementBlock as _createElementBlock, createCommentVNode as _createCommentVNode, normalizeClass as _normalizeClass, normalizeStyle as _normalizeStyle, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from "vue";

var _withScopeId = n => (_pushScopeId(""), n = n(), _popScopeId(), n);

var _hoisted_1 = {
  key: 0,
  class: "var-divider__text"
};
export function render(_ctx, _cache) {
  return _openBlock(), _createElementBlock("div", {
    class: _normalizeClass(["var-divider var--box", [_ctx.vertical ? 'var-divider--vertical' : null, _ctx.withText ? 'var-divider--with-text' : null, _ctx.isInset ? 'var-divider--inset' : null, _ctx.dashed ? 'var-divider--dashed' : null]]),
    style: _normalizeStyle(_ctx.style)
  }, [_renderSlot(_ctx.$slots, "default", {}, () => [_ctx.description ? (_openBlock(), _createElementBlock("span", _hoisted_1, _toDisplayString(_ctx.description), 1
  /* TEXT */
  )) : _createCommentVNode("v-if", true)])], 6
  /* CLASS, STYLE */
  );
}
export default defineComponent({
  render,
  name: 'VarDivider',
  props,

  setup(props, {
    slots
  }) {
    var state = reactive({
      withText: false
    });
    var isInset = computed(() => isBool(props.inset) ? props.inset : true);
    var style = computed(() => {
      var {
        inset,
        vertical,
        margin
      } = props;
      var baseStyle = {
        margin
      };
      if (isBool(inset) || inset === 0) return _extends({}, baseStyle); // -18px -> -18

      var _inset = toNumber(inset); // -18px -> 18px


      var absInsetWithUnit = Math.abs(_inset) + (inset + '').replace(_inset + '', '');
      return vertical ? _extends({}, baseStyle, {
        height: "calc(80% - " + toSizeUnit(absInsetWithUnit) + ")"
      }) : _extends({}, baseStyle, {
        width: "calc(100% - " + toSizeUnit(absInsetWithUnit) + ")",
        left: _inset > 0 ? toSizeUnit(absInsetWithUnit) : toSizeUnit(0)
      });
    });

    var checkHasText = () => {
      state.withText = Boolean(slots.default == null ? void 0 : slots.default().length) || Boolean(props.description);
    };

    onMounted(() => {
      checkHasText();
    });
    onUpdated(() => {
      checkHasText();
    });
    return _extends({}, toRefs(state), {
      style,
      isInset
    });
  }

});