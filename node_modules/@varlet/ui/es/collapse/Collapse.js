import { computed, defineComponent, nextTick, watch } from 'vue';
import { useCollapseItem } from './provide';
import { props } from './props';
import { isArray } from '../utils/shared';
import { renderSlot as _renderSlot, openBlock as _openBlock, createElementBlock as _createElementBlock, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from "vue";

var _withScopeId = n => (_pushScopeId(""), n = n(), _popScopeId(), n);

var _hoisted_1 = {
  class: "var-collapse"
};
export function render(_ctx, _cache) {
  return _openBlock(), _createElementBlock("div", _hoisted_1, [_renderSlot(_ctx.$slots, "default")]);
}
export default defineComponent({
  render,
  name: 'VarCollapse',
  props,

  setup(props) {
    var {
      length,
      collapseItem,
      bindCollapseItem
    } = useCollapseItem();
    var active = computed(() => props.modelValue);
    var offset = computed(() => props.offset);

    var checkValue = () => {
      if (!props.accordion && !isArray(props.modelValue)) {
        console.error('[Varlet] Collapse: type of prop "modelValue" should be an Array');
        return false;
      }

      if (props.accordion && isArray(props.modelValue)) {
        console.error('[Varlet] Collapse: type of prop "modelValue" should be a String or Number');
        return false;
      }

      return true;
    };

    var getValue = (value, isExpand) => {
      if (!checkValue()) return;
      if (isExpand) return props.accordion ? value : [...props.modelValue, value];
      return props.accordion ? null : props.modelValue.filter(name => name !== value);
    };

    var updateItem = (value, isExpand) => {
      var _props$onUpdateModel;

      var modelValue = getValue(value, isExpand);
      (_props$onUpdateModel = props['onUpdate:modelValue']) == null ? void 0 : _props$onUpdateModel.call(props, modelValue);
      props.onChange == null ? void 0 : props.onChange(modelValue);
    };

    var matchName = () => {
      if (props.accordion) {
        return collapseItem.find(({
          name
        }) => props.modelValue === name.value);
      }

      var filterItem = collapseItem.filter(({
        name
      }) => {
        if (name.value === undefined) return false;
        return props.modelValue.includes(name.value);
      });
      return filterItem.length ? filterItem : undefined;
    };

    var matchIndex = () => {
      if (props.accordion) {
        return collapseItem.find(({
          index,
          name
        }) => name.value === undefined ? props.modelValue === index.value : false);
      }

      return collapseItem.filter(({
        index,
        name
      }) => name.value === undefined ? props.modelValue.includes(index.value) : false);
    };

    var resize = () => {
      if (!checkValue()) return;
      var matchProviders = matchName() || matchIndex();

      if (props.accordion && !matchProviders || !props.accordion && !matchProviders.length) {
        collapseItem.forEach(provider => {
          provider.init(props.accordion, false);
        });
        return;
      }

      collapseItem.forEach(provider => {
        var isShow = props.accordion ? matchProviders === provider : matchProviders.includes(provider);
        provider.init(props.accordion, isShow);
      });
    };

    var collapseProvider = {
      active,
      offset,
      updateItem
    };
    bindCollapseItem(collapseProvider);
    watch(() => length.value, () => nextTick().then(resize));
    watch(() => props.modelValue, () => nextTick().then(resize));
  }

});