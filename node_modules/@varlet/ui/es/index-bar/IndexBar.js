function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

import { computed, defineComponent, nextTick, ref, watch, onMounted, onBeforeUnmount } from 'vue';
import { easeInOutCubic, isPlainObject, toNumber } from '../utils/shared';
import { getParentScroller, getScrollLeft, nextTickFrame, requestAnimationFrame, scrollTo as varScrollTo } from '../utils/elements';
import { useIndexAnchors } from './provide';
import { props } from './props';
import { renderSlot as _renderSlot, renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, toDisplayString as _toDisplayString, normalizeClass as _normalizeClass, normalizeStyle as _normalizeStyle, createElementVNode as _createElementVNode, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from "vue";

var _withScopeId = n => (_pushScopeId(""), n = n(), _popScopeId(), n);

var _hoisted_1 = {
  class: "var-index-bar",
  ref: "barEl"
};
var _hoisted_2 = ["onClick"];
export function render(_ctx, _cache) {
  return _openBlock(), _createElementBlock("div", _hoisted_1, [_renderSlot(_ctx.$slots, "default"), _createElementVNode("ul", {
    class: "var-index-bar__anchor-list",
    style: _normalizeStyle({
      zIndex: _ctx.toNumber(_ctx.zIndex) + 2,
      display: _ctx.hideList ? 'none' : 'block'
    })
  }, [(_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.anchorNameList, anchorName => {
    return _openBlock(), _createElementBlock("li", {
      key: anchorName,
      class: _normalizeClass(["var-index-bar__anchor-item", {
        'var-index-bar__anchor-item--active': _ctx.active === anchorName
      }]),
      style: _normalizeStyle({
        color: _ctx.active === anchorName && _ctx.highlightColor ? _ctx.highlightColor : ''
      }),
      onClick: $event => _ctx.anchorClick(anchorName)
    }, _toDisplayString(anchorName), 15
    /* TEXT, CLASS, STYLE, PROPS */
    , _hoisted_2);
  }), 128
  /* KEYED_FRAGMENT */
  ))], 4
  /* STYLE */
  )], 512
  /* NEED_PATCH */
  );
}
export default defineComponent({
  render,
  name: 'VarIndexBar',
  props,

  setup(props) {
    var {
      length,
      indexAnchors,
      bindIndexAnchors
    } = useIndexAnchors();
    var scrollEl = ref(null);
    var clickedName = ref('');
    var scroller = ref(null);
    var barEl = ref(null);
    var anchorNameList = ref([]);
    var active = ref();
    var sticky = computed(() => props.sticky);
    var cssMode = computed(() => props.cssMode);
    var stickyOffsetTop = computed(() => props.stickyOffsetTop);
    var zIndex = computed(() => props.zIndex);
    var indexBarProvider = {
      active,
      sticky,
      cssMode,
      stickyOffsetTop,
      zIndex
    };
    bindIndexAnchors(indexBarProvider);

    var emitEvent = anchor => {
      var anchorName = isPlainObject(anchor) ? anchor.name.value : anchor;
      if (anchorName === active.value) return;
      active.value = anchorName;
      props.onChange == null ? void 0 : props.onChange(anchorName);
    };

    var handleScroll = () => {
      var {
        scrollTop,
        scrollHeight
      } = scrollEl.value;
      var {
        offsetTop
      } = barEl.value;
      indexAnchors.forEach((anchor, index) => {
        var anchorTop = anchor.ownTop.value;
        var top = scrollTop - anchorTop + stickyOffsetTop.value - offsetTop;
        var distance = index === indexAnchors.length - 1 ? scrollHeight : indexAnchors[index + 1].ownTop.value - anchor.ownTop.value;

        if (top >= 0 && top < distance && !clickedName.value) {
          if (index && !props.cssMode) {
            indexAnchors[index - 1].setDisabled(true);
          }

          anchor.setDisabled(false);
          emitEvent(anchor);
        }
      });
    };

    var anchorClick = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(function* (anchorName, manualCall) {
        if (manualCall) props.onClick == null ? void 0 : props.onClick(anchorName);
        if (anchorName === active.value) return;
        var indexAnchor = indexAnchors.find(({
          name
        }) => anchorName === name.value);
        if (!indexAnchor) return;
        var top = indexAnchor.ownTop.value;
        var left = getScrollLeft(scrollEl.value);
        clickedName.value = anchorName;
        emitEvent(anchorName);
        yield varScrollTo(scrollEl.value, {
          left,
          top,
          animation: easeInOutCubic,
          duration: toNumber(props.duration)
        });
        nextTickFrame(() => {
          clickedName.value = '';
        });
      });

      return function anchorClick(_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }(); // expose


    var scrollTo = index => {
      requestAnimationFrame(() => anchorClick(index, true));
    };

    watch(() => length.value, () => nextTick(() => {
      indexAnchors.forEach(({
        name,
        setOwnTop
      }) => {
        if (name.value) anchorNameList.value.push(name.value);
        setOwnTop();
      });
    }));
    onMounted(() => {
      var _scroller$value;

      scroller.value = getParentScroller(barEl.value);
      scrollEl.value = scroller.value === window ? scroller.value.document.documentElement : scroller.value;
      (_scroller$value = scroller.value) == null ? void 0 : _scroller$value.addEventListener('scroll', handleScroll);
    });
    onBeforeUnmount(() => {
      var _scroller$value2;

      (_scroller$value2 = scroller.value) == null ? void 0 : _scroller$value2.removeEventListener('scroll', handleScroll);
    });
    return {
      barEl,
      active,
      zIndex,
      anchorNameList,
      toNumber,
      scrollTo,
      anchorClick
    };
  }

});