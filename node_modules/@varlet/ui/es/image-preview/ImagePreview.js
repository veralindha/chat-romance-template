import VarSwipe from '../swipe';
import VarSwipeItem from '../swipe-item';
import VarIcon from '../icon';
import VarPopup from '../popup';
import { defineComponent, ref, computed, watch } from 'vue';
import { props } from './props';
import { toNumber } from '../utils/shared';
var DISTANCE_OFFSET = 12;
var EVENT_DELAY = 200;
var ANIMATION_DURATION = 200;
import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, createElementVNode as _createElementVNode, normalizeStyle as _normalizeStyle, resolveComponent as _resolveComponent, withCtx as _withCtx, createBlock as _createBlock, renderSlot as _renderSlot, toDisplayString as _toDisplayString, createCommentVNode as _createCommentVNode, mergeProps as _mergeProps, createVNode as _createVNode, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from "vue";

var _withScopeId = n => (_pushScopeId(""), n = n(), _popScopeId(), n);

var _hoisted_1 = ["src", "alt"];
var _hoisted_2 = {
  key: 0,
  class: "var-image-preview__indicators"
};
export function render(_ctx, _cache) {
  var _component_var_swipe_item = _resolveComponent("var-swipe-item");

  var _component_var_swipe = _resolveComponent("var-swipe");

  var _component_var_icon = _resolveComponent("var-icon");

  var _component_var_popup = _resolveComponent("var-popup");

  return _openBlock(), _createBlock(_component_var_popup, {
    class: "var-image-preview__popup",
    "var-image-preview-cover": "",
    transition: "var-fade",
    show: _ctx.popupShow,
    overlay: false,
    "close-on-click-overlay": false,
    "lock-scroll": _ctx.lockScroll,
    teleport: _ctx.teleport,
    onOpen: _ctx.onOpen,
    onClose: _ctx.onClose,
    onClosed: _ctx.onClosed,
    onOpened: _ctx.onOpened,
    onRouteChange: _ctx.onRouteChange
  }, {
    default: _withCtx(() => [_createVNode(_component_var_swipe, _mergeProps({
      class: "var-image-preview__swipe",
      "var-image-preview-cover": "",
      touchable: _ctx.canSwipe,
      indicator: _ctx.indicator && _ctx.images.length > 1,
      "initial-index": _ctx.initialIndex,
      loop: _ctx.loop,
      onChange: _ctx.onChange
    }, _ctx.$attrs), {
      default: _withCtx(() => [(_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.images, image => {
        return _openBlock(), _createBlock(_component_var_swipe_item, {
          class: "var-image-preview__swipe-item",
          "var-image-preview-cover": "",
          key: image
        }, {
          default: _withCtx(() => [_createElementVNode("div", {
            class: "var-image-preview__zoom-container",
            style: _normalizeStyle({
              transform: "scale(" + _ctx.scale + ") translate(" + _ctx.translateX + "px, " + _ctx.translateY + "px)",
              transitionTimingFunction: _ctx.transitionTimingFunction,
              transitionDuration: _ctx.transitionDuration
            }),
            onTouchstart: _cache[0] || (_cache[0] = (...args) => _ctx.handleTouchstart && _ctx.handleTouchstart(...args)),
            onTouchmove: _cache[1] || (_cache[1] = (...args) => _ctx.handleTouchmove && _ctx.handleTouchmove(...args)),
            onTouchend: _cache[2] || (_cache[2] = (...args) => _ctx.handleTouchend && _ctx.handleTouchend(...args))
          }, [_createElementVNode("img", {
            class: "var-image-preview__image",
            src: image,
            alt: image
          }, null, 8
          /* PROPS */
          , _hoisted_1)], 36
          /* STYLE, HYDRATE_EVENTS */
          )]),
          _: 2
          /* DYNAMIC */

        }, 1024
        /* DYNAMIC_SLOTS */
        );
      }), 128
      /* KEYED_FRAGMENT */
      ))]),
      indicator: _withCtx(({
        index,
        length
      }) => [_renderSlot(_ctx.$slots, "indicator", {
        index: index,
        length: length
      }, () => [_ctx.indicator && _ctx.images.length > 1 ? (_openBlock(), _createElementBlock("div", _hoisted_2, _toDisplayString(index + 1) + " / " + _toDisplayString(length), 1
      /* TEXT */
      )) : _createCommentVNode("v-if", true)])]),
      _: 3
      /* FORWARDED */

    }, 16
    /* FULL_PROPS */
    , ["touchable", "indicator", "initial-index", "loop", "onChange"]), _renderSlot(_ctx.$slots, "close-icon", {}, () => [_ctx.closeable ? (_openBlock(), _createBlock(_component_var_icon, {
      key: 0,
      class: "var-image-preview__close-icon",
      name: "close-circle",
      "var-image-preview-cover": "",
      onClick: _ctx.close
    }, null, 8
    /* PROPS */
    , ["onClick"])) : _createCommentVNode("v-if", true)])]),
    _: 3
    /* FORWARDED */

  }, 8
  /* PROPS */
  , ["show", "lock-scroll", "teleport", "onOpen", "onClose", "onClosed", "onOpened", "onRouteChange"]);
}
export default defineComponent({
  render,
  name: 'VarImagePreview',
  components: {
    VarSwipe,
    VarSwipeItem,
    VarPopup,
    VarIcon
  },
  inheritAttrs: false,
  props,

  setup(props) {
    var popupShow = ref(false);
    var initialIndex = computed(() => {
      var {
        images,
        current
      } = props;
      var index = images.findIndex(image => image === current);
      return index >= 0 ? index : 0;
    });
    var scale = ref(1);
    var translateX = ref(0);
    var translateY = ref(0);
    var transitionTimingFunction = ref(undefined);
    var transitionDuration = ref(undefined);
    var canSwipe = ref(true);
    var startTouch = null;
    var prevTouch = null;
    var checker = null;

    var getDistance = (touch, target) => {
      var {
        clientX: touchX,
        clientY: touchY
      } = touch;
      var {
        clientX: targetX,
        clientY: targetY
      } = target;
      return Math.abs(Math.sqrt(Math.pow(targetX - touchX, 2) + Math.pow(targetY - touchY, 2)));
    };

    var createVarTouch = (touches, target) => ({
      clientX: touches.clientX,
      clientY: touches.clientY,
      timestamp: Date.now(),
      target
    });

    var zoomIn = () => {
      scale.value = toNumber(props.zoom);
      canSwipe.value = false;
      prevTouch = null;
      window.setTimeout(() => {
        transitionTimingFunction.value = 'linear';
        transitionDuration.value = '0s';
      }, ANIMATION_DURATION);
    };

    var zoomOut = () => {
      scale.value = 1;
      translateX.value = 0;
      translateY.value = 0;
      canSwipe.value = true;
      prevTouch = null;
      transitionTimingFunction.value = undefined;
      transitionDuration.value = undefined;
    };

    var isDoubleTouch = currentTouch => {
      if (!prevTouch) {
        return false;
      }

      return getDistance(prevTouch, currentTouch) <= DISTANCE_OFFSET && currentTouch.timestamp - prevTouch.timestamp <= EVENT_DELAY && prevTouch.target === currentTouch.target;
    };

    var isTapTouch = target => {
      if (!startTouch || !prevTouch) {
        return false;
      }

      return getDistance(startTouch, prevTouch) <= DISTANCE_OFFSET && (target === startTouch.target || target.parentNode === startTouch.target);
    };

    var handleTouchend = event => {
      checker = window.setTimeout(() => {
        isTapTouch(event.target) && close();
        startTouch = null;
      }, EVENT_DELAY);
    };

    var handleTouchstart = event => {
      checker && window.clearTimeout(checker);
      var {
        touches
      } = event;
      var currentTouch = createVarTouch(touches[0], event.currentTarget);
      startTouch = currentTouch;

      if (isDoubleTouch(currentTouch)) {
        scale.value > 1 ? zoomOut() : zoomIn();
        return;
      }

      prevTouch = currentTouch;
    };

    var getZoom = target => {
      var {
        offsetWidth,
        offsetHeight
      } = target;
      var {
        naturalWidth,
        naturalHeight
      } = target.querySelector('.var-image-preview__image');
      return {
        width: offsetWidth,
        height: offsetHeight,
        imageRadio: naturalHeight / naturalWidth,
        rootRadio: offsetHeight / offsetWidth,
        zoom: toNumber(props.zoom)
      };
    };

    var getLimitX = target => {
      var {
        zoom,
        imageRadio,
        rootRadio,
        width,
        height
      } = getZoom(target);

      if (!imageRadio) {
        return 0;
      }

      var displayWidth = imageRadio > rootRadio ? height / imageRadio : width;
      return Math.max(0, (zoom * displayWidth - width) / 2) / zoom;
    };

    var getLimitY = target => {
      var {
        zoom,
        imageRadio,
        rootRadio,
        width,
        height
      } = getZoom(target);

      if (!imageRadio) {
        return 0;
      }

      var displayHeight = imageRadio > rootRadio ? height : width * imageRadio;
      return Math.max(0, (zoom * displayHeight - height) / 2) / zoom;
    };

    var getMoveTranslate = (current, move, limit) => {
      if (current + move >= limit) {
        return limit;
      }

      if (current + move <= -limit) {
        return -limit;
      }

      return current + move;
    };

    var handleTouchmove = event => {
      if (!prevTouch) {
        return;
      }

      var target = event.currentTarget;
      var {
        touches
      } = event;
      var currentTouch = createVarTouch(touches[0], target);

      if (scale.value > 1) {
        var moveX = currentTouch.clientX - prevTouch.clientX;
        var moveY = currentTouch.clientY - prevTouch.clientY;
        var limitX = getLimitX(target);
        var limitY = getLimitY(target);
        translateX.value = getMoveTranslate(translateX.value, moveX, limitX);
        translateY.value = getMoveTranslate(translateY.value, moveY, limitY);
      }

      prevTouch = currentTouch;
    };

    var close = () => {
      var _props$onUpdateShow2;

      if (scale.value > 1) {
        zoomOut();
        setTimeout(() => {
          var _props$onUpdateShow;

          return (_props$onUpdateShow = props['onUpdate:show']) == null ? void 0 : _props$onUpdateShow.call(props, false);
        }, ANIMATION_DURATION);
        return;
      }

      (_props$onUpdateShow2 = props['onUpdate:show']) == null ? void 0 : _props$onUpdateShow2.call(props, false);
    };

    watch(() => props.show, newValue => {
      popupShow.value = newValue;
    }, {
      immediate: true
    });
    return {
      initialIndex,
      popupShow,
      scale,
      translateX,
      translateY,
      canSwipe,
      transitionTimingFunction,
      transitionDuration,
      handleTouchstart,
      handleTouchmove,
      handleTouchend,
      close
    };
  }

});