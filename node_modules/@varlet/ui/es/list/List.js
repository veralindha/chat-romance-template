function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

import VarLoading from '../loading';
import Ripple from '../ripple';
import { defineComponent, onMounted, onUnmounted, ref, nextTick } from 'vue';
import { getParentScroller, isHidden, toPxNum } from '../utils/elements';
import { props } from './props';
import { isNumber, dt } from '../utils/shared';
import { pack } from '../locale';
import { renderSlot as _renderSlot, toDisplayString as _toDisplayString, createElementVNode as _createElementVNode, resolveComponent as _resolveComponent, createVNode as _createVNode, createCommentVNode as _createCommentVNode, createTextVNode as _createTextVNode, resolveDirective as _resolveDirective, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from "vue";

var _withScopeId = n => (_pushScopeId(""), n = n(), _popScopeId(), n);

var _hoisted_1 = {
  class: "var-list var--box",
  ref: "listEl"
};
var _hoisted_2 = {
  class: "var-list__loading"
};
var _hoisted_3 = {
  class: "var-list__loading-text"
};
var _hoisted_4 = {
  class: "var-list__finished"
};
var _hoisted_5 = {
  class: "var-list__detector",
  ref: "detectorEl"
};
export function render(_ctx, _cache) {
  var _component_var_loading = _resolveComponent("var-loading");

  var _directive_ripple = _resolveDirective("ripple");

  return _openBlock(), _createElementBlock("div", _hoisted_1, [_renderSlot(_ctx.$slots, "default"), _ctx.loading ? _renderSlot(_ctx.$slots, "loading", {
    key: 0
  }, () => [_createElementVNode("div", _hoisted_2, [_createElementVNode("div", _hoisted_3, _toDisplayString(_ctx.dt(_ctx.loadingText, _ctx.pack.listLoadingText)), 1
  /* TEXT */
  ), _createVNode(_component_var_loading, {
    size: "mini",
    radius: 10
  })])]) : _createCommentVNode("v-if", true), _ctx.finished ? _renderSlot(_ctx.$slots, "finished", {
    key: 1
  }, () => [_createElementVNode("div", _hoisted_4, _toDisplayString(_ctx.dt(_ctx.finishedText, _ctx.pack.listFinishedText)), 1
  /* TEXT */
  )]) : _createCommentVNode("v-if", true), _ctx.error ? _renderSlot(_ctx.$slots, "error", {
    key: 2
  }, () => [_withDirectives(_createElementVNode("div", {
    class: "var-list__error",
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.load && _ctx.load(...args))
  }, [_createTextVNode(_toDisplayString(_ctx.dt(_ctx.errorText, _ctx.pack.listErrorText)), 1
  /* TEXT */
  )], 512
  /* NEED_PATCH */
  ), [[_directive_ripple]])]) : _createCommentVNode("v-if", true), _createElementVNode("div", _hoisted_5, null, 512
  /* NEED_PATCH */
  )], 512
  /* NEED_PATCH */
  );
}
export default defineComponent({
  render,
  name: 'VarList',
  directives: {
    Ripple
  },
  components: {
    VarLoading
  },
  props,

  setup(props) {
    var listEl = ref(null);
    var detectorEl = ref(null);
    var scroller;

    var load = () => {
      var _props$onUpdateError, _props$onUpdateLoadi;

      (_props$onUpdateError = props['onUpdate:error']) == null ? void 0 : _props$onUpdateError.call(props, false);
      (_props$onUpdateLoadi = props['onUpdate:loading']) == null ? void 0 : _props$onUpdateLoadi.call(props, true);
      props.onLoad == null ? void 0 : props.onLoad();
    };

    var isReachBottom = () => {
      var containerBottom = scroller === window ? window.innerHeight : scroller.getBoundingClientRect().bottom;
      var {
        bottom: detectorBottom
      } = detectorEl.value.getBoundingClientRect();
      return detectorBottom - toPxNum(props.offset) <= containerBottom;
    }; // expose


    var check = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(function* () {
        yield nextTick();

        if (isHidden(listEl.value)) {
          return;
        }

        var {
          loading,
          finished,
          error
        } = props;

        if (!loading && !finished && !error && isReachBottom()) {
          load();
        }
      });

      return function check() {
        return _ref.apply(this, arguments);
      };
    }();

    onMounted(() => {
      scroller = getParentScroller(listEl.value);
      props.immediateCheck && check();
      scroller.addEventListener('scroll', check);
    });
    onUnmounted(() => {
      scroller.removeEventListener('scroll', check);
    });
    return {
      pack,
      listEl,
      detectorEl,
      dt,
      isNumber,
      load,
      check
    };
  }

});