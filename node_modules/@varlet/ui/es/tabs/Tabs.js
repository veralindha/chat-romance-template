import VarSticky from '../sticky';
import { defineComponent, watch, ref, computed, Transition, nextTick, onMounted, onUnmounted } from 'vue';
import { props } from './props';
import { useTabList } from './provide';
import { isNumber, linear } from '../utils/shared';
import { toSizeUnit, scrollTo } from '../utils/elements';
import { renderSlot as _renderSlot, normalizeClass as _normalizeClass, normalizeStyle as _normalizeStyle, createElementVNode as _createElementVNode, mergeProps as _mergeProps, resolveDynamicComponent as _resolveDynamicComponent, withCtx as _withCtx, openBlock as _openBlock, createBlock as _createBlock } from "vue";
export function render(_ctx, _cache) {
  return _openBlock(), _createBlock(_resolveDynamicComponent(_ctx.sticky ? 'var-sticky' : _ctx.Transition), {
    "offset-top": _ctx.sticky ? _ctx.offsetTop : null
  }, {
    default: _withCtx(() => [_createElementVNode("div", _mergeProps({
      class: ["var-tabs var--box", ["var-tabs--item-" + _ctx.itemDirection, "var-tabs--layout-" + _ctx.layoutDirection + "-padding", _ctx.elevation ? "var-elevation--4" : null, _ctx.fixedBottom ? 'var-tabs--fixed-bottom' : null]],
      style: {
        background: _ctx.color
      }
    }, _ctx.$attrs), [_createElementVNode("div", {
      class: _normalizeClass(["var-tabs__tab-wrap", [_ctx.scrollable ? "var-tabs--layout-" + _ctx.layoutDirection + "-scrollable" : null, "var-tabs--layout-" + _ctx.layoutDirection]]),
      ref: "scrollerEl"
    }, [_renderSlot(_ctx.$slots, "default"), _createElementVNode("div", {
      class: _normalizeClass(["var-tabs__indicator", ["var-tabs--layout-" + _ctx.layoutDirection + "-indicator"]]),
      style: _normalizeStyle({
        width: _ctx.layoutDirection === 'horizontal' ? _ctx.indicatorWidth : _ctx.toSizeUnit(_ctx.indicatorSize),
        height: _ctx.layoutDirection === 'horizontal' ? _ctx.toSizeUnit(_ctx.indicatorSize) : _ctx.indicatorHeight,
        transform: _ctx.layoutDirection === 'horizontal' ? "translateX(" + _ctx.indicatorX + ")" : "translateY(" + _ctx.indicatorY + ")",
        background: _ctx.indicatorColor || _ctx.activeColor
      })
    }, null, 6
    /* CLASS, STYLE */
    )], 2
    /* CLASS */
    )], 16
    /* FULL_PROPS */
    )]),
    _: 3
    /* FORWARDED */

  }, 8
  /* PROPS */
  , ["offset-top"]);
}
export default defineComponent({
  render,
  name: 'VarTabs',
  components: {
    VarSticky
  },
  inheritAttrs: false,
  props,

  setup(props) {
    var indicatorWidth = ref('0px');
    var indicatorHeight = ref('0px');
    var indicatorX = ref('0px');
    var indicatorY = ref('0px');
    var scrollable = ref(false);
    var scrollerEl = ref(null);
    var active = computed(() => props.active);
    var activeColor = computed(() => props.activeColor);
    var inactiveColor = computed(() => props.inactiveColor);
    var disabledColor = computed(() => props.disabledColor);
    var itemDirection = computed(() => props.itemDirection);
    var {
      tabList,
      bindTabList,
      length
    } = useTabList();

    var onTabClick = tab => {
      var _tab$name$value, _props$onUpdateActiv;

      var currentActive = (_tab$name$value = tab.name.value) != null ? _tab$name$value : tab.index.value;
      var {
        active,
        onChange,
        onClick
      } = props;
      (_props$onUpdateActiv = props['onUpdate:active']) == null ? void 0 : _props$onUpdateActiv.call(props, currentActive);
      onClick == null ? void 0 : onClick(currentActive);
      currentActive !== active && (onChange == null ? void 0 : onChange(currentActive));
    };

    var matchName = () => {
      return tabList.find(({
        name
      }) => props.active === name.value);
    };

    var matchIndex = () => {
      return tabList.find(({
        index
      }) => props.active === index.value);
    };

    var matchBoundary = () => {
      var _props$onUpdateActiv2, _props$onUpdateActiv3;

      if (length.value === 0) {
        return;
      }

      var {
        active
      } = props;
      isNumber(active) ? active > length.value - 1 ? (_props$onUpdateActiv2 = props['onUpdate:active']) == null ? void 0 : _props$onUpdateActiv2.call(props, length.value - 1) : (_props$onUpdateActiv3 = props['onUpdate:active']) == null ? void 0 : _props$onUpdateActiv3.call(props, 0) : null;
      return matchIndex();
    };

    var watchScrollable = () => {
      scrollable.value = tabList.length >= 5;
    };

    var moveIndicator = ({
      element
    }) => {
      var el = element.value;

      if (props.layoutDirection === 'horizontal') {
        indicatorWidth.value = (el == null ? void 0 : el.offsetWidth) + "px";
        indicatorX.value = (el == null ? void 0 : el.offsetLeft) + "px";
      } else {
        indicatorHeight.value = (el == null ? void 0 : el.offsetHeight) + "px";
        indicatorY.value = (el == null ? void 0 : el.offsetTop) + "px";
      }
    };

    var scrollToCenter = ({
      element
    }) => {
      if (!scrollable.value) {
        return;
      }

      var scroller = scrollerEl.value;
      var el = element.value;

      if (props.layoutDirection === 'horizontal') {
        var left = el.offsetLeft + el.offsetWidth / 2 - scroller.offsetWidth / 2;
        scrollTo(scroller, {
          left,
          animation: linear
        });
      } else {
        var top = el.offsetTop + el.offsetHeight / 2 - scroller.offsetHeight / 2;
        scrollTo(scroller, {
          top,
          animation: linear
        });
      }
    }; // expose


    var resize = () => {
      var tab = matchName() || matchIndex() || matchBoundary();

      if (!tab || tab.disabled.value) {
        return;
      }

      watchScrollable();
      moveIndicator(tab);
      scrollToCenter(tab);
    };

    var tabsProvider = {
      active,
      activeColor,
      inactiveColor,
      disabledColor,
      itemDirection,
      resize,
      onTabClick
    };
    bindTabList(tabsProvider);
    watch(() => length.value, () => nextTick().then(resize));
    watch(() => props.active, resize);
    onMounted(() => window.addEventListener('resize', resize));
    onUnmounted(() => window.removeEventListener('resize', resize));
    return {
      indicatorWidth,
      indicatorHeight,
      indicatorX,
      indicatorY,
      scrollable,
      scrollerEl,
      Transition,
      toSizeUnit,
      resize
    };
  }

});