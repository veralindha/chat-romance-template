import VarButton from '../button';
import VarPopup from '../popup';
import { defineComponent, watch, ref, computed, Transition, toRaw } from 'vue';
import { props } from './props';
import { isArray, dt } from '../utils/shared';
import { toPxNum, getTranslate } from '../utils/elements';
import { pack } from '../locale';
var MOMENTUM_RECORD_TIME = 300;
var MOMENTUM_ALLOW_DISTANCE = 15;
var sid = 0;
import { renderSlot as _renderSlot, toDisplayString as _toDisplayString, createTextVNode as _createTextVNode, resolveComponent as _resolveComponent, withCtx as _withCtx, createVNode as _createVNode, createElementVNode as _createElementVNode, renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, normalizeStyle as _normalizeStyle, withModifiers as _withModifiers, mergeProps as _mergeProps, resolveDynamicComponent as _resolveDynamicComponent, createBlock as _createBlock, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from "vue";

var _withScopeId = n => (_pushScopeId(""), n = n(), _popScopeId(), n);

var _hoisted_1 = {
  class: "var-picker__toolbar"
};
var _hoisted_2 = {
  class: "var-picker__title"
};
var _hoisted_3 = ["onTouchstart", "onTouchmove", "onTouchend"];
var _hoisted_4 = ["onTransitionend"];
var _hoisted_5 = {
  class: "var-picker__text"
};
export function render(_ctx, _cache) {
  var _component_var_button = _resolveComponent("var-button");

  return _openBlock(), _createBlock(_resolveDynamicComponent(_ctx.dynamic ? 'var-popup' : _ctx.Transition), _mergeProps(_ctx.dynamic ? {
    onOpen: _ctx.onOpen,
    onOpened: _ctx.onOpened,
    onClose: _ctx.onClose,
    onClosed: _ctx.onClosed,
    onClickOverlay: _ctx.onClickOverlay,
    onRouteChange: _ctx.onRouteChange,
    closeOnClickOverlay: _ctx.closeOnClickOverlay,
    teleport: _ctx.teleport,
    show: _ctx.show,
    'onUpdate:show': _ctx.handlePopupUpdateShow,
    position: 'bottom',
    class: 'var-picker__popup'
  } : null, {
    "var-picker-cover": ""
  }), {
    default: _withCtx(() => [_createElementVNode("div", _mergeProps({
      class: "var-picker"
    }, _ctx.$attrs), [_createElementVNode("div", _hoisted_1, [_renderSlot(_ctx.$slots, "cancel", {}, () => [_createVNode(_component_var_button, {
      class: "var-picker__cancel-button",
      "var-picker-cover": "",
      text: "",
      "text-color": _ctx.cancelButtonTextColor,
      onClick: _ctx.cancel
    }, {
      default: _withCtx(() => [_createTextVNode(_toDisplayString(_ctx.dt(_ctx.cancelButtonText, _ctx.pack.pickerCancelButtonText)), 1
      /* TEXT */
      )]),
      _: 1
      /* STABLE */

    }, 8
    /* PROPS */
    , ["text-color", "onClick"])]), _renderSlot(_ctx.$slots, "title", {}, () => [_createElementVNode("div", _hoisted_2, _toDisplayString(_ctx.dt(_ctx.title, _ctx.pack.pickerTitle)), 1
    /* TEXT */
    )]), _renderSlot(_ctx.$slots, "confirm", {}, () => [_createVNode(_component_var_button, {
      class: "var-picker__confirm-button",
      text: "",
      "var-picker-cover": "",
      "text-color": _ctx.confirmButtonTextColor,
      onClick: _ctx.confirm
    }, {
      default: _withCtx(() => [_createTextVNode(_toDisplayString(_ctx.dt(_ctx.confirmButtonText, _ctx.pack.pickerConfirmButtonText)), 1
      /* TEXT */
      )]),
      _: 1
      /* STABLE */

    }, 8
    /* PROPS */
    , ["text-color", "onClick"])])]), _createElementVNode("div", {
      class: "var-picker__columns",
      style: _normalizeStyle({
        height: _ctx.columnHeight + "px"
      })
    }, [(_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.scrollColumns, c => {
      return _openBlock(), _createElementBlock("div", {
        class: "var-picker__column",
        key: c.id,
        onTouchstart: $event => _ctx.handleTouchstart($event, c),
        onTouchmove: _withModifiers($event => _ctx.handleTouchmove($event, c), ["prevent"]),
        onTouchend: $event => _ctx.handleTouchend($event, c)
      }, [_createElementVNode("div", {
        class: "var-picker__scroller",
        ref: el => _ctx.getScrollEl(el, c),
        style: _normalizeStyle({
          transform: "translateY(" + c.translate + "px)",
          transitionDuration: c.duration + "ms",
          transitionProperty: c.duration ? 'transform' : 'none'
        }),
        onTransitionend: $event => _ctx.handleTransitionend(c)
      }, [(_openBlock(true), _createElementBlock(_Fragment, null, _renderList(c.column.texts, t => {
        return _openBlock(), _createElementBlock("div", {
          class: "var-picker__option",
          style: _normalizeStyle({
            height: _ctx.optionHeight + "px"
          }),
          key: t
        }, [_createElementVNode("div", _hoisted_5, _toDisplayString(t), 1
        /* TEXT */
        )], 4
        /* STYLE */
        );
      }), 128
      /* KEYED_FRAGMENT */
      ))], 44
      /* STYLE, PROPS, HYDRATE_EVENTS */
      , _hoisted_4)], 40
      /* PROPS, HYDRATE_EVENTS */
      , _hoisted_3);
    }), 128
    /* KEYED_FRAGMENT */
    )), _createElementVNode("div", {
      class: "var-picker__picked",
      style: _normalizeStyle({
        top: _ctx.center + "px",
        height: _ctx.optionHeight + "px"
      })
    }, null, 4
    /* STYLE */
    ), _createElementVNode("div", {
      class: "var-picker__mask",
      style: _normalizeStyle({
        backgroundSize: "100% " + (_ctx.columnHeight - _ctx.optionHeight) / 2 + "px"
      })
    }, null, 4
    /* STYLE */
    )], 4
    /* STYLE */
    )], 16
    /* FULL_PROPS */
    )]),
    _: 3
    /* FORWARDED */

  }, 16
  /* FULL_PROPS */
  );
}
export default defineComponent({
  render,
  name: 'VarPicker',
  components: {
    VarButton,
    VarPopup
  },
  inheritAttrs: false,
  props,

  setup(props) {
    var scrollColumns = ref([]);
    var optionHeight = computed(() => toPxNum(props.optionHeight));
    var optionCount = computed(() => toPxNum(props.optionCount));
    var center = computed(() => optionCount.value * optionHeight.value / 2 - optionHeight.value / 2);
    var columnHeight = computed(() => optionCount.value * optionHeight.value);
    var prevIndexes = [];

    var getScrollEl = (el, scrollColumn) => {
      scrollColumn.scrollEl = el;
    };

    var handlePopupUpdateShow = value => {
      var _props$onUpdateShow;

      (_props$onUpdateShow = props['onUpdate:show']) == null ? void 0 : _props$onUpdateShow.call(props, value);
    };

    var limitTranslate = scrollColumn => {
      var START_LIMIT = optionHeight.value + center.value;
      var END_LIMIT = center.value - scrollColumn.column.texts.length * optionHeight.value;

      if (scrollColumn.translate >= START_LIMIT) {
        scrollColumn.translate = START_LIMIT;
      }

      if (scrollColumn.translate <= END_LIMIT) {
        scrollColumn.translate = END_LIMIT;
      }
    };

    var boundaryIndex = (scrollColumn, index) => {
      var {
        length
      } = scrollColumn.column.texts;
      index = index >= length ? length - 1 : index;
      index = index <= 0 ? 0 : index;
      return index;
    };

    var getIndex = scrollColumn => {
      var index = Math.round((center.value - scrollColumn.translate) / optionHeight.value);
      return boundaryIndex(scrollColumn, index);
    };

    var getPicked = () => {
      var texts = scrollColumns.value.map(scrollColumn => scrollColumn.column.texts[scrollColumn.index]);
      var indexes = scrollColumns.value.map(scrollColumn => scrollColumn.index);
      return {
        texts,
        indexes
      };
    };

    var scrollTo = (scrollColumn, index, duration, noEmit = false) => {
      var translate = center.value - boundaryIndex(scrollColumn, index) * optionHeight.value;

      if (translate === scrollColumn.translate) {
        scrollColumn.scrolling = false;
        !noEmit && change(scrollColumn);
      }

      scrollColumn.translate = translate;
      scrollColumn.duration = duration;
    };

    var momentum = (scrollColumn, distance, duration) => {
      scrollColumn.translate += Math.abs(distance / duration) / 0.003 * (distance < 0 ? -1 : 1);
    };

    var handleTouchstart = (event, scrollColumn) => {
      scrollColumn.touching = true;
      scrollColumn.scrolling = false;
      scrollColumn.duration = 0;
      scrollColumn.translate = getTranslate(scrollColumn.scrollEl);
    };

    var handleTouchmove = (event, scrollColumn) => {
      if (!scrollColumn.touching) {
        return;
      }

      var {
        clientY
      } = event.touches[0];
      var moveY = scrollColumn.prevY !== undefined ? clientY - scrollColumn.prevY : 0;
      scrollColumn.prevY = clientY;
      scrollColumn.translate += moveY;
      limitTranslate(scrollColumn);
      var now = performance.now();

      if (now - scrollColumn.momentumTime > MOMENTUM_RECORD_TIME) {
        scrollColumn.momentumTime = now;
        scrollColumn.momentumPrevY = scrollColumn.translate;
      }
    };

    var handleTouchend = (event, scrollColumn) => {
      scrollColumn.touching = false;
      scrollColumn.scrolling = true;
      scrollColumn.prevY = undefined;
      var distance = scrollColumn.translate - scrollColumn.momentumPrevY;
      var duration = performance.now() - scrollColumn.momentumTime;
      var shouldMomentum = Math.abs(distance) >= MOMENTUM_ALLOW_DISTANCE && duration <= MOMENTUM_RECORD_TIME;
      shouldMomentum && momentum(scrollColumn, distance, duration);
      scrollColumn.index = getIndex(scrollColumn);
      scrollTo(scrollColumn, scrollColumn.index, shouldMomentum ? 1000 : 200);
    };

    var handleTransitionend = scrollColumn => {
      scrollColumn.scrolling = false;
      change(scrollColumn);
    };

    var normalizeNormalColumns = normalColumns => {
      return normalColumns.map(column => {
        var _normalColumn$initial;

        var normalColumn = isArray(column) ? {
          texts: column
        } : column;
        var scrollColumn = {
          id: sid++,
          prevY: undefined,
          momentumPrevY: undefined,
          touching: false,
          translate: center.value,
          index: (_normalColumn$initial = normalColumn.initialIndex) != null ? _normalColumn$initial : 0,
          duration: 0,
          momentumTime: 0,
          column: normalColumn,
          scrollEl: null,
          scrolling: false
        };
        scrollTo(scrollColumn, scrollColumn.index, 200);
        return scrollColumn;
      });
    };

    var normalizeCascadeColumns = cascadeColumns => {
      var scrollColumns = [];
      createChildren(scrollColumns, cascadeColumns);
      return scrollColumns;
    };

    var createChildren = (scrollColumns, children) => {
      if (isArray(children) && children.length) {
        var scrollColumn = {
          id: sid++,
          prevY: undefined,
          momentumPrevY: undefined,
          touching: false,
          translate: center.value,
          index: 0,
          duration: 0,
          momentumTime: 0,
          column: {
            texts: children.map(cascadeColumn => cascadeColumn[props.textKey])
          },
          columns: children,
          scrollEl: null,
          scrolling: false
        };
        scrollColumns.push(scrollColumn);
        createChildren(scrollColumns, scrollColumn.columns[scrollColumn.index].children);
      }
    };

    var rebuildChildren = scrollColumn => {
      scrollColumns.value.splice(scrollColumns.value.indexOf(scrollColumn) + 1);
      createChildren(scrollColumns.value, scrollColumn.columns[scrollColumn.index].children);
    };

    var change = scrollColumn => {
      var {
        cascade,
        onChange
      } = props;
      cascade && rebuildChildren(scrollColumn);
      var hasScrolling = scrollColumns.value.some(scrollColumn => scrollColumn.scrolling);

      if (hasScrolling) {
        return;
      }

      var {
        texts,
        indexes
      } = getPicked();
      var samePicked = indexes.every((index, idx) => index === prevIndexes[idx]);

      if (samePicked) {
        return;
      }

      prevIndexes = [...indexes];
      onChange == null ? void 0 : onChange(texts, indexes);
    };

    var stopScroll = () => {
      if (props.cascade) {
        var currentScrollColumn = scrollColumns.value.find(scrollColumn => scrollColumn.scrolling);

        if (currentScrollColumn) {
          currentScrollColumn.translate = getTranslate(currentScrollColumn.scrollEl);
          currentScrollColumn.index = getIndex(currentScrollColumn);
          scrollTo(currentScrollColumn, currentScrollColumn.index, 0, true);
          currentScrollColumn.scrolling = false;
          rebuildChildren(currentScrollColumn);
        }
      } else {
        scrollColumns.value.forEach(scrollColumn => {
          scrollColumn.translate = getTranslate(scrollColumn.scrollEl);
          scrollColumn.index = getIndex(scrollColumn);
          scrollTo(scrollColumn, scrollColumn.index, 0);
        });
      }
    }; // expose


    var confirm = () => {
      stopScroll();
      var {
        texts,
        indexes
      } = getPicked();
      prevIndexes = [...indexes];
      props.onConfirm == null ? void 0 : props.onConfirm(texts, indexes);
    }; // expose


    var cancel = () => {
      stopScroll();
      var {
        texts,
        indexes
      } = getPicked();
      prevIndexes = [...indexes];
      props.onCancel == null ? void 0 : props.onCancel(texts, indexes);
    };

    watch(() => props.columns, newValue => {
      scrollColumns.value = props.cascade ? normalizeCascadeColumns(toRaw(newValue)) : normalizeNormalColumns(toRaw(newValue));
      var {
        indexes
      } = getPicked();
      prevIndexes = [...indexes];
    }, {
      immediate: true
    });
    return {
      pack,
      optionHeight,
      optionCount,
      scrollColumns,
      columnHeight,
      center,
      Transition,
      getScrollEl,
      handlePopupUpdateShow,
      handleTouchstart,
      handleTouchmove,
      handleTouchend,
      handleTransitionend,
      confirm,
      cancel,
      dt
    };
  }

});