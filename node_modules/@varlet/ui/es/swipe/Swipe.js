import { defineComponent, ref, computed, watch, onMounted, onUnmounted } from 'vue';
import { useSwipeItems } from './provide';
import { nextTickFrame } from '../utils/elements';
import { props } from './props';
import { isNumber, toNumber } from '../utils/shared';
var SWIPE_DELAY = 250;
var SWIPE_DISTANCE = 20;
import { renderSlot as _renderSlot, normalizeClass as _normalizeClass, normalizeStyle as _normalizeStyle, createElementVNode as _createElementVNode, renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, createCommentVNode as _createCommentVNode, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from "vue";

var _withScopeId = n => (_pushScopeId(""), n = n(), _popScopeId(), n);

var _hoisted_1 = {
  class: "var-swipe",
  ref: "swipeEl"
};
var _hoisted_2 = ["onClick"];
export function render(_ctx, _cache) {
  return _openBlock(), _createElementBlock("div", _hoisted_1, [_createElementVNode("div", {
    class: _normalizeClass(["var-swipe__track", [_ctx.vertical ? 'var-swipe--vertical' : null]]),
    style: _normalizeStyle({
      width: !_ctx.vertical ? _ctx.trackSize + "px" : undefined,
      height: _ctx.vertical ? _ctx.trackSize + "px" : undefined,
      transform: "translate" + (_ctx.vertical ? 'Y' : 'X') + "(" + _ctx.translate + "px)",
      transitionDuration: _ctx.lockDuration ? "0ms" : _ctx.toNumber(_ctx.duration) + "ms"
    }),
    onTouchstart: _cache[0] || (_cache[0] = (...args) => _ctx.handleTouchstart && _ctx.handleTouchstart(...args)),
    onTouchmove: _cache[1] || (_cache[1] = (...args) => _ctx.handleTouchmove && _ctx.handleTouchmove(...args)),
    onTouchend: _cache[2] || (_cache[2] = (...args) => _ctx.handleTouchend && _ctx.handleTouchend(...args))
  }, [_renderSlot(_ctx.$slots, "default")], 38
  /* CLASS, STYLE, HYDRATE_EVENTS */
  ), _renderSlot(_ctx.$slots, "indicator", {
    index: _ctx.index,
    length: _ctx.length
  }, () => [_ctx.indicator && _ctx.length ? (_openBlock(), _createElementBlock("div", {
    key: 0,
    class: _normalizeClass(["var-swipe__indicators", [_ctx.vertical ? 'var-swipe--indicators-vertical' : null]])
  }, [(_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.length, (l, idx) => {
    return _openBlock(), _createElementBlock("div", {
      class: _normalizeClass(["var-swipe__indicator", [_ctx.index === idx ? 'var-swipe--indicator-active' : null, _ctx.vertical ? 'var-swipe--indicator-vertical' : null]]),
      style: _normalizeStyle({
        background: _ctx.indicatorColor
      }),
      key: l,
      onClick: $event => _ctx.to(idx)
    }, null, 14
    /* CLASS, STYLE, PROPS */
    , _hoisted_2);
  }), 128
  /* KEYED_FRAGMENT */
  ))], 2
  /* CLASS */
  )) : _createCommentVNode("v-if", true)])], 512
  /* NEED_PATCH */
  );
}
export default defineComponent({
  render,
  name: 'VarSwipe',
  props,

  setup(props) {
    var swipeEl = ref(null);
    var size = ref(0);
    var vertical = computed(() => props.vertical);
    var trackSize = ref(0);
    var translate = ref(0);
    var lockDuration = ref(false);
    var index = ref(0);
    var {
      swipeItems,
      bindSwipeItems,
      length
    } = useSwipeItems();
    var touching = false;
    var timer = -1;
    var startX;
    var startY;
    var startTime;
    var prevX;
    var prevY;

    var findSwipeItem = idx => swipeItems.find(({
      index
    }) => index.value === idx);

    var dispatchBorrower = () => {
      if (!props.loop) {
        return;
      } // track越左边界


      if (translate.value >= 0) {
        findSwipeItem(length.value - 1).setTranslate(-trackSize.value);
      } // track越右边界


      if (translate.value <= -(trackSize.value - size.value)) {
        findSwipeItem(0).setTranslate(trackSize.value);
      } // track没越界


      if (translate.value > -(trackSize.value - size.value) && translate.value < 0) {
        findSwipeItem(length.value - 1).setTranslate(0);
        findSwipeItem(0).setTranslate(0);
      }
    };

    var getSwipeIndex = targetSwipeIndex => {
      var swipeIndex = isNumber(targetSwipeIndex) ? targetSwipeIndex : Math.floor((translate.value - size.value / 2) / -size.value);
      var {
        loop
      } = props;

      if (swipeIndex <= -1) {
        return loop ? -1 : 0;
      }

      if (swipeIndex >= length.value) {
        return loop ? length.value : length.value - 1;
      }

      return swipeIndex;
    };

    var swipeIndexToIndex = swipeIndex => {
      var {
        loop
      } = props;

      if (swipeIndex === -1) {
        return loop ? length.value - 1 : 0;
      }

      if (swipeIndex === length.value) {
        return loop ? 0 : length.value - 1;
      }

      return swipeIndex;
    };

    var boundaryIndex = index => {
      var {
        loop
      } = props;

      if (index < 0) {
        return loop ? length.value - 1 : 0;
      }

      if (index > length.value - 1) {
        return loop ? 0 : length.value - 1;
      }

      return index;
    };

    var fixPosition = fn => {
      var overLeft = translate.value >= size.value;
      var overRight = translate.value <= -trackSize.value;
      var leftTranslate = 0;
      var rightTranslate = -(trackSize.value - size.value);
      lockDuration.value = true; // 检测是否有越界情况 越界修正

      if (overLeft || overRight) {
        lockDuration.value = true;
        translate.value = overRight ? leftTranslate : rightTranslate;
        findSwipeItem(0).setTranslate(0);
        findSwipeItem(length.value - 1).setTranslate(0);
      }

      nextTickFrame(() => {
        lockDuration.value = false;
        fn == null ? void 0 : fn();
      });
    };

    var initialIndex = () => {
      index.value = boundaryIndex(toNumber(props.initialIndex));
    };

    var startAutoplay = () => {
      var {
        autoplay
      } = props;

      if (!autoplay || length.value <= 1) {
        return;
      }

      stopAutoplay();
      timer = window.setTimeout(() => {
        next();
        startAutoplay();
      }, toNumber(autoplay));
    };

    var stopAutoplay = () => {
      timer && clearInterval(timer);
    };

    var getDirection = (x, y) => {
      if (x > y && x > 10) {
        return 'horizontal';
      }

      if (y > x && y > 10) {
        return 'vertical';
      }
    };

    var handleTouchstart = event => {
      if (length.value <= 1 || !props.touchable) {
        return;
      }

      var {
        clientX,
        clientY
      } = event.touches[0];
      startX = clientX;
      startY = clientY;
      startTime = performance.now();
      touching = true;
      stopAutoplay();
      fixPosition(() => {
        lockDuration.value = true;
      });
    };

    var handleTouchmove = event => {
      var {
        touchable,
        vertical
      } = props;

      if (!touching || !touchable) {
        return;
      }

      var {
        clientX,
        clientY
      } = event.touches[0];
      var deltaX = Math.abs(clientX - startX);
      var deltaY = Math.abs(clientY - startY);
      var direction = getDirection(deltaX, deltaY);
      var expectDirection = vertical ? 'vertical' : 'horizontal';

      if (direction === expectDirection) {
        event.preventDefault();
        var moveX = prevX !== undefined ? clientX - prevX : 0;
        var moveY = prevY !== undefined ? clientY - prevY : 0;
        prevX = clientX;
        prevY = clientY;
        translate.value += vertical ? moveY : moveX;
        dispatchBorrower();
      }
    };

    var handleTouchend = () => {
      if (!touching) {
        return;
      }

      var {
        vertical,
        onChange
      } = props;
      var positive = vertical ? prevY < startY : prevX < startX;
      var distance = vertical ? Math.abs(startY - prevY) : Math.abs(startX - prevX);
      var quickSwiping = performance.now() - startTime <= SWIPE_DELAY && distance >= SWIPE_DISTANCE;
      var swipeIndex = quickSwiping ? positive ? getSwipeIndex(index.value + 1) : getSwipeIndex(index.value - 1) : getSwipeIndex();
      touching = false;
      lockDuration.value = false;
      prevX = undefined;
      prevY = undefined;
      translate.value = swipeIndex * -size.value;
      var prevIndex = index.value;
      index.value = swipeIndexToIndex(swipeIndex);
      startAutoplay();
      prevIndex !== index.value && (onChange == null ? void 0 : onChange(index.value));
    }; // expose


    var resize = () => {
      lockDuration.value = true;
      size.value = props.vertical ? swipeEl.value.offsetHeight : swipeEl.value.offsetWidth;
      trackSize.value = size.value * length.value;
      translate.value = index.value * -size.value;
      swipeItems.forEach(swipeItem => {
        swipeItem.setTranslate(0);
      });
      startAutoplay();
      setTimeout(() => {
        lockDuration.value = false;
      });
    }; // expose


    var next = () => {
      if (length.value <= 1) {
        return;
      }

      var {
        loop,
        onChange
      } = props;
      var currentIndex = index.value;
      index.value = boundaryIndex(currentIndex + 1);
      onChange == null ? void 0 : onChange(index.value);
      fixPosition(() => {
        if (currentIndex === length.value - 1 && loop) {
          findSwipeItem(0).setTranslate(trackSize.value);
          translate.value = length.value * -size.value;
          return;
        }

        if (currentIndex !== length.value - 1) {
          translate.value = index.value * -size.value;
        }
      });
    }; // expose


    var prev = () => {
      if (length.value <= 1) {
        return;
      }

      var {
        loop,
        onChange
      } = props;
      var currentIndex = index.value;
      index.value = boundaryIndex(currentIndex - 1);
      onChange == null ? void 0 : onChange(index.value);
      fixPosition(() => {
        if (currentIndex === 0 && loop) {
          findSwipeItem(length.value - 1).setTranslate(-trackSize.value);
          translate.value = size.value;
          return;
        }

        if (currentIndex !== 0) {
          translate.value = index.value * -size.value;
        }
      });
    }; // expose


    var to = idx => {
      if (length.value <= 1 || idx === index.value) {
        return;
      }

      idx = idx < 0 ? 0 : idx;
      idx = idx >= length.value ? length.value : idx;
      var task = idx > index.value ? next : prev;
      Array.from({
        length: Math.abs(idx - index.value)
      }).forEach(task);
    };

    var swipeProvider = {
      size,
      vertical
    };
    bindSwipeItems(swipeProvider);
    watch(() => length.value, () => {
      initialIndex();
      resize();
    });
    onMounted(() => {
      window.addEventListener('resize', resize);
    });
    onUnmounted(() => {
      window.removeEventListener('resize', resize);
      stopAutoplay();
    });
    return {
      length,
      index,
      swipeEl,
      trackSize,
      translate,
      lockDuration,
      handleTouchstart,
      handleTouchmove,
      handleTouchend,
      next,
      prev,
      to,
      resize,
      toNumber
    };
  }

});