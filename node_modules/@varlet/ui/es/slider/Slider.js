import { defineComponent, ref, onMounted, computed, reactive, nextTick, watch } from 'vue';
import { useValidation } from '../utils/components';
import { useForm } from '../form/provide';
import { getLeft } from '../utils/elements';
import { isArray, isNumber, toNumber } from '../utils/shared';
import { props } from './props';
import VarFormDetails from '../form-details';
var Thumbs;

(function (Thumbs) {
  Thumbs["First"] = "1";
  Thumbs["Second"] = "2";
})(Thumbs || (Thumbs = {}));

import { normalizeStyle as _normalizeStyle, createElementVNode as _createElementVNode, renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, renderSlot as _renderSlot, normalizeClass as _normalizeClass, toDisplayString as _toDisplayString, resolveComponent as _resolveComponent, createVNode as _createVNode, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from "vue";

var _withScopeId = n => (_pushScopeId(""), n = n(), _popScopeId(), n);

var _hoisted_1 = {
  class: "var-slider"
};
var _hoisted_2 = {
  class: "var-slider__track"
};
var _hoisted_3 = ["onTouchstart", "onTouchmove", "onTouchend", "onTouchcancel"];
export function render(_ctx, _cache) {
  var _component_var_form_details = _resolveComponent("var-form-details");

  return _openBlock(), _createElementBlock("div", _hoisted_1, [_createElementVNode("div", {
    class: _normalizeClass(["var-slider-block", [_ctx.isDisabled ? 'var-slider__disable' : null, _ctx.errorMessage ? 'var-slider__error' : null]]),
    style: _normalizeStyle({
      height: _ctx.thumbSize === undefined ? _ctx.thumbSize : 3 * _ctx.toNumber(_ctx.thumbSize) + "px",
      margin: _ctx.thumbSize === undefined ? _ctx.thumbSize : "0 " + _ctx.toNumber(_ctx.thumbSize) / 2 + "px"
    }),
    ref: "sliderEl",
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.click && _ctx.click(...args))
  }, [_createElementVNode("div", _hoisted_2, [_createElementVNode("div", {
    class: "var-slider__track-background",
    style: _normalizeStyle({
      background: _ctx.trackColor,
      height: _ctx.trackHeight + 'px'
    })
  }, null, 4
  /* STYLE */
  ), _createElementVNode("div", {
    class: "var-slider__track-fill",
    style: _normalizeStyle(_ctx.getFillStyle)
  }, null, 4
  /* STYLE */
  )]), (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.thumbList, item => {
    return _openBlock(), _createElementBlock("div", {
      class: "var-slider__thumb",
      key: item.enumValue,
      style: _normalizeStyle({
        left: item.value + "%",
        zIndex: _ctx.thumbsProps[item.enumValue].active ? 1 : undefined
      }),
      onTouchstart: $event => _ctx.start($event, item.enumValue),
      onTouchmove: $event => _ctx.move($event, item.enumValue),
      onTouchend: $event => _ctx.end(item.enumValue),
      onTouchcancel: $event => _ctx.end(item.enumValue)
    }, [_renderSlot(_ctx.$slots, "button", {
      currentValue: item.value
    }, () => [_createElementVNode("div", {
      class: "var-slider__thumb-block",
      style: _normalizeStyle({
        background: _ctx.thumbColor,
        height: _ctx.thumbSize + 'px',
        width: _ctx.thumbSize + 'px'
      })
    }, null, 4
    /* STYLE */
    ), _createElementVNode("div", {
      class: _normalizeClass(["var-slider__thumb-ripple", [_ctx.thumbsProps[item.enumValue].active ? 'var-slider__thumb-ripple-active' : null]]),
      style: _normalizeStyle({
        background: _ctx.thumbColor,
        height: _ctx.thumbSize === undefined ? undefined : _ctx.thumbsProps[item.enumValue].active ? 3 * _ctx.toNumber(_ctx.thumbSize) + "px" : '0px',
        width: _ctx.thumbSize === undefined ? undefined : _ctx.thumbsProps[item.enumValue].active ? 3 * _ctx.toNumber(_ctx.thumbSize) + "px" : '0px'
      })
    }, null, 6
    /* CLASS, STYLE */
    ), _createElementVNode("div", {
      class: _normalizeClass(["var-slider__thumb-label", [_ctx.showLabel(item.enumValue) ? 'var-slider__thumb-label-active' : null]]),
      style: _normalizeStyle({
        background: _ctx.labelColor,
        color: _ctx.labelTextColor,
        height: _ctx.thumbSize === undefined ? _ctx.thumbSize : 2 * _ctx.toNumber(_ctx.thumbSize) + "px",
        width: _ctx.thumbSize === undefined ? _ctx.thumbSize : 2 * _ctx.toNumber(_ctx.thumbSize) + "px"
      })
    }, [_createElementVNode("span", null, _toDisplayString(item.value), 1
    /* TEXT */
    )], 6
    /* CLASS, STYLE */
    )])], 44
    /* STYLE, PROPS, HYDRATE_EVENTS */
    , _hoisted_3);
  }), 128
  /* KEYED_FRAGMENT */
  ))], 6
  /* CLASS, STYLE */
  ), _createVNode(_component_var_form_details, {
    "error-message": _ctx.errorMessage,
    class: "var-slider__form",
    "var-slider-cover": ""
  }, null, 8
  /* PROPS */
  , ["error-message"])]);
}
export default defineComponent({
  render,
  name: 'VarSlider',
  components: {
    VarFormDetails
  },
  props,

  setup(props) {
    var {
      bindForm,
      form
    } = useForm();
    var {
      errorMessage,
      validateWithTrigger: vt,
      validate: v,
      resetValidation
    } = useValidation();

    var validate = () => v(props.rules, props.modelValue);

    var getThumbProps = () => ({
      startPosition: 0,
      currentLeft: 0,
      active: false,
      percentValue: 0
    });

    var validateWithTrigger = () => nextTick(() => vt(['onChange'], 'onChange', props.rules, props.modelValue));

    var sliderEl = ref(null);
    var maxWidth = ref(0);
    var isScroll = ref(false);
    var thumbsProps = reactive({
      [Thumbs.First]: getThumbProps(),
      [Thumbs.Second]: getThumbProps()
    });
    var unitWidth = computed(() => maxWidth.value / 100 * toNumber(props.step));
    var thumbList = computed(() => {
      var list = [{
        value: props.modelValue,
        enumValue: Thumbs.First
      }];

      if (props.range && isArray(props.modelValue)) {
        list = [{
          value: props.modelValue[0],
          enumValue: Thumbs.First
        }, {
          value: props.modelValue[1],
          enumValue: Thumbs.Second
        }];
      }

      return list;
    });

    var showLabel = type => {
      if (props.labelVisible === 'always') return true;
      if (props.labelVisible === 'never') return false;
      return thumbsProps[type].active;
    };

    var getFillStyle = computed(() => {
      var {
        activeColor,
        range,
        modelValue
      } = props;
      var width = range && isArray(modelValue) ? Math.abs(modelValue[0] - modelValue[1]) : modelValue;
      var left = range && isArray(modelValue) ? Math.min(modelValue[0], modelValue[1]) : 0;
      return {
        width: width + "%",
        left: left + "%",
        background: activeColor
      };
    });
    var isDisabled = computed(() => props.disabled || (form == null ? void 0 : form.disabled.value));
    var isReadonly = computed(() => props.readonly || (form == null ? void 0 : form.readonly.value));

    var setPercent = (moveDistance, type) => {
      var rangeValue = [];
      var {
        step,
        range,
        modelValue,
        onChange
      } = props;
      var stepNumber = toNumber(step);
      var roundDistance = Math.round(moveDistance / unitWidth.value);
      var curValue = roundDistance * stepNumber;
      var prevValue = thumbsProps[type].percentValue;
      thumbsProps[type].percentValue = curValue / stepNumber;

      if (range && isArray(modelValue)) {
        rangeValue = type === Thumbs.First ? [curValue, modelValue[1]] : [modelValue[0], curValue];
      }

      if (prevValue !== curValue) {
        var _props$onUpdateModel;

        var value = range ? rangeValue : curValue;
        onChange == null ? void 0 : onChange(value);
        (_props$onUpdateModel = props['onUpdate:modelValue']) == null ? void 0 : _props$onUpdateModel.call(props, value);
        validateWithTrigger();
      }
    };

    var getType = offset => {
      if (!props.range) return Thumbs.First;
      var thumb1Distance = thumbsProps[Thumbs.First].percentValue * unitWidth.value;
      var thumb2Distance = thumbsProps[Thumbs.Second].percentValue * unitWidth.value;
      var offsetToThumb1 = Math.abs(offset - thumb1Distance);
      var offsetToThumb2 = Math.abs(offset - thumb2Distance);
      return offsetToThumb1 <= offsetToThumb2 ? Thumbs.First : Thumbs.Second;
    };

    var start = (event, type) => {
      if (!maxWidth.value) maxWidth.value = sliderEl.value.offsetWidth;
      if (isDisabled.value || isReadonly.value) return;
      props.onStart == null ? void 0 : props.onStart();
      isScroll.value = true;
      thumbsProps[type].startPosition = event.touches[0].clientX;
    };

    var move = (event, type) => {
      if (isDisabled.value || isReadonly.value || !isScroll.value) return;
      var moveDistance = event.touches[0].clientX - thumbsProps[type].startPosition + thumbsProps[type].currentLeft;
      thumbsProps[type].active = true;
      if (moveDistance <= 0) moveDistance = 0;else if (moveDistance >= maxWidth.value) moveDistance = maxWidth.value;
      setPercent(moveDistance, type);
    };

    var end = type => {
      var {
        range,
        modelValue,
        onEnd
      } = props;
      if (isDisabled.value || isReadonly.value) return;
      var rangeValue = [];
      thumbsProps[type].currentLeft = thumbsProps[type].percentValue * unitWidth.value;
      thumbsProps[type].active = false;
      var curValue = thumbsProps[type].percentValue;

      if (range && isArray(modelValue)) {
        rangeValue = type === Thumbs.First ? [curValue, modelValue[1]] : [modelValue[0], curValue];
      }

      onEnd == null ? void 0 : onEnd(range ? rangeValue : curValue);
      isScroll.value = false;
    };

    var click = event => {
      if (isDisabled.value || isReadonly.value) return;
      if (event.target.closest('.var-slider__thumb')) return;
      var offset = event.clientX - getLeft(event.currentTarget);
      var type = getType(offset);
      setPercent(offset, type);
      end(type);
    };

    var stepValidator = () => {
      var stepNumber = toNumber(props.step);

      if (isNaN(stepNumber)) {
        console.warn('[Varlet] Slider: type of prop "step" should be Number');
        return false;
      }

      if (stepNumber < 1 || stepNumber > 100) {
        console.warn('[Varlet] Slider: "step" should be >= 0 and <= 100');
        return false;
      }

      if (parseInt("" + props.step, 10) !== stepNumber) {
        console.warn('[Varlet] Slider: "step" should be an Integer');
        return false;
      }

      return true;
    };

    var valueValidator = () => {
      var {
        range,
        modelValue
      } = props;

      if (range && !isArray(modelValue)) {
        console.error('[Varlet] Slider: "modelValue" should be an Array');
        return false;
      }

      if (!range && isArray(modelValue)) {
        console.error('[Varlet] Slider: "modelValue" should be a Number');
        return false;
      }

      if (range && isArray(modelValue) && modelValue.length < 2) {
        console.error('[Varlet] Slider: "modelValue" should have two value');
        return false;
      }

      return true;
    };

    var setProps = (modelValue = props.modelValue, step = toNumber(props.step)) => {
      if (props.range && isArray(modelValue)) {
        thumbsProps[Thumbs.First].percentValue = modelValue[0] / step;
        thumbsProps[Thumbs.First].currentLeft = thumbsProps[Thumbs.First].percentValue * unitWidth.value;
        thumbsProps[Thumbs.Second].percentValue = modelValue[1] / step;
        thumbsProps[Thumbs.Second].currentLeft = thumbsProps[Thumbs.Second].percentValue * unitWidth.value;
      } else if (isNumber(modelValue)) {
        thumbsProps[Thumbs.First].currentLeft = modelValue / step * unitWidth.value;
      }
    };

    watch([() => props.modelValue, () => props.step], ([modelValue, step]) => {
      if (!stepValidator() || !valueValidator() || isScroll.value) return;
      setProps(modelValue, toNumber(step));
    });
    watch(maxWidth, () => setProps());
    onMounted(() => {
      if (!stepValidator() || !valueValidator()) return;
      maxWidth.value = sliderEl.value.offsetWidth;
    });

    var reset = () => {
      var _props$onUpdateModel2;

      var resetValue = props.range ? [0, 0] : 0;
      (_props$onUpdateModel2 = props['onUpdate:modelValue']) == null ? void 0 : _props$onUpdateModel2.call(props, resetValue);
      resetValidation();
    };

    var sliderProvider = {
      reset,
      validate,
      resetValidation
    };
    bindForm == null ? void 0 : bindForm(sliderProvider);
    return {
      Thumbs,
      sliderEl,
      getFillStyle,
      isDisabled,
      errorMessage,
      thumbsProps,
      thumbList,
      toNumber,
      showLabel,
      start,
      move,
      end,
      click
    };
  }

});